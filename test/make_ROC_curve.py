# From the data generated by make_ROC_data.py we can now construct a ROC curve.

# Imports
import numpy as np
import matplotlib.pyplot as plt
import os


# Function to get arrays of TPs and FPs from predictions and classes.
def get_ROC_curve(predictions, classes):

    n_values = len(classes)
    positives = classes > 0
    negatives = classes == 0
    n_positives = np.sum(positives)
    n_negatives = n_values - n_positives

    tps = np.array([])
    fps = np.array([])

    # # For each threshold that was used we check how many TP and FP we would have gotten.
    # for prediction in np.unique(predictions):
    # Instead of going through each threshold it is much more efficient to go through 100 possible ones and then make
    # the plot. This works just as well with a lot of datapoints.
    for prediction in np.arange(0, 1, 0.01):
        # print(prediction)

        tps = np.append(tps, np.sum((predictions >= prediction) & positives) / n_positives)
        fps = np.append(fps, np.sum((predictions >= prediction) & negatives) / n_negatives)

    # Sort by fps.
    inds = np.argsort(fps)

    return tps[inds], fps[inds]


# Plot it.
plt.figure()
plt.plot([0, 1], [0, 1], '--')
plt.xlim([0, 1])
plt.ylim([0, 1])

# Make the ROC curves for different settings of gate_width_ratios.
for gate_width_ratio in [0.1, 0.25, 0.5]:
    print(gate_width_ratio)

    # Load the data.
    all_masks = np.load(os.path.join('../', 'results', 'all_masks-{}.npy'.format(gate_width_ratio)))
    all_masks_hat = np.load(os.path.join('../', 'results', 'all_masks_hat-{}.npy'.format(gate_width_ratio)))

    # Generate the points.
    TP, FP = get_ROC_curve(all_masks_hat, all_masks)

    # Plot.
    plt.plot(FP, TP, label='ratio = {}'.format(np.round(gate_width_ratio, 2)))

plt.legend()
plt.show()
